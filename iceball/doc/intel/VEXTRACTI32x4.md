# VEXTRACTI128/VEXTRACTI32x4/VEXTRACTI64x2/VEXTRACTI32x8/VEXTRACTI64x4

Extract Packed Integer Values

VEXTRACTI128/VEXTRACTI32x4 and VEXTRACTI64x2 extract 128-bits of doubleword integer values from the source operand (the second operand) and store to the low 128-bit of the destination operand (the first operand).
The 128-bit data extraction occurs at an 128-bit granular offset specified by imm8[0] (256-bit) or imm8[1:0] as the multiply factor.
The destination may be either a vector register or an 128-bit memory location.VEXTRACTI32x4: The low 128-bit of the destination operand is updated at 32-bit granularity according to the writemask.VEXTRACTI64x2: The low 128-bit of the destination operand is updated at 64-bit granularity according to the writemask.VEXTRACTI32x8 and VEXTRACTI64x4 extract 256-bits of quadword integer values from the source operand (the second operand) and store to the low 256-bit of the destination operand (the first operand).
The 256-bit data extraction occurs at an 256-bit granular offset specified by imm8[0] (256-bit) or imm8[0] as the multiply factor The destination may be either a vector register or a 256-bit memory location.VEXTRACTI32x8: The low 256-bit of the destination operVEXTRACTI64x4: The low 256-bit of the destination operand is updated at 64-bit granularity according to the writemask.VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.The high 7 bits (6 bits in EVEX.512) of the immediate are ignored.If VEXTRACTI128 is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will cause an #UD exception.

## Exceptions

- Other Exceptions
  > VEX-encoded instructions, see Table2-23, "Type 6 Class Exception Conditions."
  > EVEX-encoded instructions, see Table2-54, "Type E6NF Class Exception Conditions."
  > Additionally:
  - #UD - IF VEX.L = 0.
- SIMD Floating-Point Exceptions
  > None

## Operation

```C
VEXTRACTI32x4 (EVEX encoded versions) when destination is a registerVL = 256, 512IF VL = 256CASE (imm8[0]) OF0: TMP_DEST[127:0] := SRC1[127:0]1: TMP_DEST[127:0] := SRC1[255:128]ESAC.FI;IF VL = 512 CASE (imm8[1:0]) OF00: TMP_DEST[127:0] := SRC1[127:0]01: TMP_DEST[127:0] := SRC1[255:128]10: TMP_DEST[127:0] := SRC1[383:256]11: TMP_DEST[127:0] := SRC1[511:384]ESAC.FI;FOR j := 0 TO 3i := j * 32IF k1[j] OR *no writemask*THEN DEST[i+31:i] := TMP_DEST[i+31:i]ELSE IF *merging-masking*; merging-maskingTHEN *DEST[i+31:i] remains unchanged*ELSE *zeroing-masking*; zeroing-maskingDEST[i+31:i] := 0FIFI;ENDFORDEST[MAXVL-1:128] := 0VEXTRACTI32x4 (EVEX encoded versions) when destination is memoryVL = 256, 512IF VL = 256CASE (imm8[0]) OF0: TMP_DEST[127:0] := SRC1[127:0]1: TMP_DEST[127:0] := SRC1[255:128]ESAC.FI;IF VL = 512 CASE (imm8[1:0]) OF00: TMP_DEST[127:0] := SRC1[127:0]01: TMP_DEST[127:0] := SRC1[255:128]10: TMP_DEST[127:0] := SRC1[383:256]FI;FOR j := 0 TO 3i := j * 32IF k1[j] OR *no writemask*THEN DEST[i+31:i] := TMP_DEST[i+31:i]ELSE *DEST[i+31:i] remains unchanged*; merging-maskingFI;ENDFORVEXTRACTI64x2 (EVEX encoded versions) when destination is a registerVL = 256, 512IF VL = 256CASE (imm8[0]) OF0: TMP_DEST[127:0] := SRC1[127:0]1: TMP_DEST[127:0] := SRC1[255:128]ESAC.FI;IF VL = 512 CASE (imm8[1:0]) OF00: TMP_DEST[127:0] := SRC1[127:0]01: TMP_DEST[127:0] := SRC1[255:128]10: TMP_DEST[127:0] := SRC1[383:256]11: TMP_DEST[127:0] := SRC1[511:384]ESAC.FI;FOR j := 0 TO 1i := j * 64IF k1[j] OR *no writemask*THEN DEST[i+63:i] := TMP_DEST[i+63:i]ELSE IF *merging-masking*; merging-maskingTHEN *DEST[i+63:i] remains unchanged*ELSE *zeroing-masking*; zeroing-maskingDEST[i+63:i] := 0FIFI;ENDFORDEST[MAXVL-1:128] := 0VEXTRACTI64x2 (EVEX encoded versions) when destination is memoryVL = 256, 512IF VL = 256CASE (imm8[0]) OF0: TMP_DEST[127:0] := SRC1[127:0]1: TMP_DEST[127:0] := SRC1[255:128]ESAC.FI;IF VL = 512 CASE (imm8[1:0]) OF00: TMP_DEST[127:0] := SRC1[127:0]11: TMP_DEST[127:0] := SRC1[511:384]ESAC.FI;FOR j := 0 TO 1i := j * 64IF k1[j] OR *no writemask*THEN DEST[i+63:i] := TMP_DEST[i+63:i]ELSE *DEST[i+63:i] remains unchanged*; merging-maskingFI;ENDFORVEXTRACTI32x8 (EVEX.U1.512 encoded version) when destination is a registerVL = 512CASE (imm8[0]) OF0: TMP_DEST[255:0] := SRC1[255:0]1: TMP_DEST[255:0] := SRC1[511:256]ESAC.FOR j := 0 TO 7i := j * 32IF k1[j] OR *no writemask*THEN DEST[i+31:i] := TMP_DEST[i+31:i]ELSE IF *merging-masking*; merging-maskingTHEN *DEST[i+31:i] remains unchanged*ELSE *zeroing-masking*; zeroing-maskingDEST[i+31:i] := 0FIFI;ENDFORDEST[MAXVL-1:256] := 0VEXTRACTI32x8 (EVEX.U1.512 encoded version) when destination is memoryCASE (imm8[0]) OF0: TMP_DEST[255:0] := SRC1[255:0]1: TMP_DEST[255:0] := SRC1[511:256]ESAC.FOR j := 0 TO 7i := j * 32IF k1[j] OR *no writemask*THEN DEST[i+31:i] := TMP_DEST[i+31:i]ELSE *DEST[i+31:i] remains unchanged*; merging-maskingFI;ENDFORVEXTRACTI64x4 (EVEX.512 encoded version) when destination is a registerVL = 512CASE (imm8[0]) OF0: TMP_DEST[255:0] := SRC1[255:0]FOR j := 0 TO 3i := j * 64IF k1[j] OR *no writemask*THEN DEST[i+63:i] := TMP_DEST[i+63:i]ELSE IF *merging-masking*; merging-maskingTHEN *DEST[i+63:i] remains unchanged*ELSE *zeroing-masking*; zeroing-maskingDEST[i+63:i] := 0FIFI;ENDFORDEST[MAXVL-1:256] := 0VEXTRACTI64x4 (EVEX.512 encoded version) when destination is memoryCASE (imm8[0]) OF0: TMP_DEST[255:0] := SRC1[255:0]1: TMP_DEST[255:0] := SRC1[511:256]ESAC.FOR j := 0 TO 3i := j * 64IF k1[j] OR *no writemask*THEN DEST[i+63:i] := TMP_DEST[i+63:i]ELSE *DEST[i+63:i] remains unchanged*; merging-maskingFI;ENDFORVEXTRACTI128 (memory destination form)CASE (imm8[0]) OF0: DEST[127:0] := SRC1[127:0]1: DEST[127:0] := SRC1[255:128]ESAC.VEXTRACTI128 (register destination form)CASE (imm8[0]) OF0: DEST[127:0] := SRC1[127:0]1: DEST[127:0] := SRC1[255:128]ESAC.DEST[MAXVL-1:128] := 0Intel C/C++ Compiler Intrinsic EquivalentVEXTRACTI32x4 __m128i _mm512_extracti32x4_epi32(__m512i a, const int nidx);VEXTRACTI32x4 __m128i _mm512_mask_extracti32x4_epi32(__m128i s, __mmask8 k, __m512i a, const int nidx);VEXTRACTI32x4 __m128i _mm512_maskz_extracti32x4_epi32( __mmask8 k, __m512i a, const int nidx);VEXTRACTI32x4 __m128i _mm256_extracti32x4_epi32(__m256i a, const int nidx);VEXTRACTI32x4 __m128i _mm256_mask_extracti32x4_epi32(__m128i s, __mmask8 k, __m256i a, const int nidx);VEXTRACTI32x4 __m128i _mm256_maskz_extracti32x4_epi32( __mmask8 k, __m256i a, const int nidx);VEXTRACTI32x8 __m256i _mm512_extracti32x8_epi32(__m512i a, const int nidx);VEXTRACTI32x8 __m256i _mm512_mask_extracti32x8_epi32(__m256i s, __mmask8 k, __m512i a, const int nidx);VEXTRACTI32x8 __m256i _mm512_maskz_extracti32x8_epi32( __mmask8 k, __m512i a, const int nidx);VEXTRACTI64x2 __m128i _mm512_extracti64x2_epi64(__m512i a, const int nidx);VEXTRACTI64x2 __m128i _mm512_mask_extracti64x2_epi64(__m128i s, __mmask8 k, __m512i a, const int nidx);VEXTRACTI64x2 __m128i _mm256_mask_extracti64x2_epi64(__m128i s, __mmask8 k, __m256i a, const int nidx);VEXTRACTI64x2 __m128i _mm256_maskz_extracti64x2_epi64( __mmask8 k, __m256i a, const int nidx);VEXTRACTI64x4 __m256i _mm512_extracti64x4_epi64(__m512i a, const int nidx);VEXTRACTI64x4 __m256i _mm512_mask_extracti64x4_epi64(__m256i s, __mmask8 k, __m512i a, const int nidx);VEXTRACTI64x4 __m256i _mm512_maskz_extracti64x4_epi64( __mmask8 k, __m512i a, const int nidx);VEXTRACTI128 __m128i _mm256_extracti128_si256(__m256i a, int offset);
```
