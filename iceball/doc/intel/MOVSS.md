# MOVSS

Move or Merge Scalar Single Precision Floating-Point Value

InstructionMode Feature SupportFlagF3 0F 10 /rAV/VSSEMerge scalar single precision floating-point value from MOVSS xmm1, xmm2xmm2 to xmm1 register.F3 0F 10 /rAV/VSSELoad scalar single precision floating-point value from MOVSS xmm1, m32m32 to xmm1 register.VEX.LIG.F3.0F.WIG 10 /rBV/VAVXMerge scalar single precision floating-point value from VMOVSS xmm1, xmm2, xmm3xmm2 and xmm3 to xmm1 registerVEX.LIG.F3.0F.WIG 10 /rDV/VAVXLoad scalar single precision floating-point value from VMOVSS xmm1, m32m32 to xmm1 register.F3 0F 11 /rCV/VSSEMove scalar single precision floating-point value from MOVSS xmm2/m32, xmm1xmm1 register to xmm2/m32.VEX.LIG.F3.0F.WIG 11 /rEV/VAVXMove scalar single precision floating-point value from VMOVSS xmm1, xmm2, xmm3xmm2 and xmm3 to xmm1 register.VEX.LIG.F3.0F.WIG 11 /rCV/VAVXMove scalar single precision floating-point value from VMOVSS m32, xmm1xmm1 register to m32.EVEX.LLIG.F3.0F.W0 10 /rBV/VAVX512FMove scalar single precision floating-point value from VMOVSS xmm1 {k1}{z}, xmm2, xmm3xmm2 and xmm3 to xmm1 register under writemask k1.EVEX.LLIG.F3.0F.W0 10 /rFV/VAVX512FMove scalar single precision floating-point values from VMOVSS xmm1 {k1}{z}, m32m32 to xmm1 under writemask k1.EVEX.LLIG.F3.0F.W0 11 /rEV/VAVX512FMove scalar single precision floating-point value from VMOVSS xmm1 {k1}{z}, xmm2, xmm3xmm2 and xmm3 to xmm1 register under writemask k1.EVEX.LLIG.F3.0F.W0 11 /rGV/VAVX512FMove scalar single precision floating-point values from VMOVSS m32 {k1}, xmm1xmm1 to m32 under writemask k1.Instruction Operand EncodingOp/EnTuple TypeOperand 1Operand 2Operand 3Operand 4AN/AModRM:reg (r, w)ModRM:r/m (r)N/AN/ABN/AModRM:reg (w)VEX.vvvv (r)ModRM:r/m (r)N/ACN/AModRM:r/m (w)ModRM:reg (r)N/AN/ADN/AModRM:reg (w)ModRM:r/m (r)N/AN/AEN/AModRM:r/m (w)EVEX.vvvv (r)ModRM:reg (r)N/AFTuple1 ScalarModRM:reg (r, w)ModRM:r/m (r)N/AN/AGTuple1 ScalarModRM:r/m (w)ModRM:reg (r)N/AN/AMoves a scalar single precision floating-point value from the source operand (second operand) to the destination operand (first operand).
The source and destination operands can be XMM registers or 32-bit memory locations.
This instruction can be used to move a single precision floating-point value to and from the low doubleword of an XMM register and a 32-bit memory location, or to move a single precision floating-point value between the low doublewords of two XMM registers.
The instruction cannot be used to transfer data between memory locations.Legacy version: When the source and destination operanoperand is an XMM registers, Bits (127:32) of the destination operand is cleared to all 0s, bits MAXVL:128 of the destination operand remains unchanged.
VEX and EVEX encoded register-register syntax: Moves a scalar single precision floating-point value from the second source operand (the third operand) to the low doubleword element of the destination operand (the first operand).
Bits 127:32 of the destination operand are copied from the first source operand (the second operand).
Bits (MAXVL-1:128) of the corresponding destination register are zeroed.VEX and EVEX encoded memory load syntax: When the source operand is a memory location and destination operand is an XMM registers, bits MAXVL:32 of the destination operand is cleared to all 0s.EVEX encoded versions: The low doubleword of the destination is updated according to the writemask.Note: For memory store form instruction "VMOVSS m32, xmm1", VEX.vvvv is reserved and must be 1111b other-wise instruction will #UD.
For memory store form instruction "VMOVSS mv {k1}, xmm1", EVEX.vvvv is reserved and must be 1111b otherwise instruction will #UD.Software should ensure VMOVSS is encoded with VEX.L=0.
Encoding VMOVSS with VEX.L=1 may encounter unpre-dictable behavior across different processor generations.

## Exceptions

- SIMD Floating-Point Exceptions
  > None.
- Other Exceptions
  > Non-EVEX-encoded instruction, see Table2-22, "T
  > ype 5 Class Exception Conditions," additionally:

## Operation

```C
VMOVSS (EVEX.LLIG.F3.0F.W0 11 /r When the Source Operand is Memory and the Destination is an XMM Register)IF k1[0] or *no writemask*THENDEST[31:0] := SRC[31:0]ELSE IF *merging-masking*; merging-maskingTHEN *DEST[31:0] remains unchanged*ELSE ; zeroing-maskingTHEN DEST[31:0] := 0FI;FI;DEST[MAXVL-1:32] := 0VMOVSS (EVEX.LLIG.F3.0F.W0 10 /r When the Source Operand is an XMM Register and the Destination is Memory)IF k1[0] or *no writemask*THENDEST[31:0] := SRC[31:0]ELSE*DEST[31:0] remains unchanged* ; merging-maskingFI;VMOVSS (EVEX.LLIG.F3.0F.W0 10/11 /r Where the Source and Destination are XMM Registers)IF k1[0] or *no writemask*THENDEST[31:0] := SRC2[31:0]ELSE IF *merging-masking*; merging-maskingTHEN *DEST[31:0] remains unchanged*ELSE ; zeroing-maskingTHEN DEST[31:0] := 0FI;FI;DEST[127:32] := SRC1[127:32]DEST[MAXVL-1:128] := 0MOVSS (Legacy SSE Version When the Source and Destination Operands are Both XMM Registers)VMOVSS (VEX.128.F3.0F 11 /r Where the Destination is an XMM Register)DEST[31:0] := SRC2[31:0]DEST[127:32] := SRC1[127:32]DEST[MAXVL-1:128] := 0VMOVSS (VEX.128.F3.0F 10 /r Where the Source and Destination are XMM Registers)DEST[31:0] := SRC2[31:0]DEST[127:32] := SRC1[127:32]DEST[MAXVL-1:128] := 0VMOVSS (VEX.128.F3.0F 10 /r When the Source Operand is Memory and the Destination is an XMM Register)DEST[31:0] := SRC[31:0]DEST[MAXVL-1:32] := 0MOVSS/VMOVSS (When the Source Operand is an XMM Register and the Destination is Memory)DEST[31:0] := SRC[31:0]MOVSS (Legacy SSE Version when the Source Operand is Memory and the Destination is an XMM Register)DEST[31:0] := SRC[31:0]DEST[127:32] := 0DEST[MAXVL-1:128] (Unmodified)Intel C/C++ Compiler Intrinsic EquivalentVMOVSS __m128 _mm_mask_load_ss(__m128 s, __mmask8 k, float * p); VMOVSS __m128 _mm_maskz_load_ss( __mmask8 k, float * p); VMOVSS __m128 _mm_mask_move_ss(__m128 sh, __mmask8 k, __m128 sl, __m128 a); VMOVSS __m128 _mm_maskz_move_ss( __mmask8 k, __m128 s, __m128 a); VMOVSS void _mm_mask_store_ss(float * p, __mmask8 k, __m128 a); MOVSS __m128 _mm_load_ss(float * p)MOVSS void_mm_store_ss(float * p, __m128 a)MOVSS __m128 _mm_move_ss(__m128 a, __m128 b)
```
