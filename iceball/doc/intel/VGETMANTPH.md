# VGETMANTPH

Extract FP16 Vector of Normalized Mantissas from FP16 Vector

This instruction converts the FP16 values in the source operand (the second operand) to FP16 values with the mantissa normalization and sign control specified by the imm8 byte, see Table 5-9.
The converted results are written to the destination operand (the first operand) using writemask k1.
The normalized mantissa is specified by interv (imm8[1:0]) and the sign control (SC) is specified by bits 3:2 of the immediate byte.The destination elements are updated according to the writemask.Table 5-9.
imm8 Controls for VGETMANTPH/VGETMANTSHimm8 BitsDefinitionimm8[7:4]Must be zero.imm8[3:2]Sign Control (SC)0b00: Sign(SRC) 0b01: 00b1x: QNaN_Indefinite if sign(SRC)!=0imm8[1:0]Interv0b00: Interval is [1, 2) 0b01: Interval is [1/2, 2) 0b10: Interval is [1/2, 1)0b11: Interval is [3/4, 3/2)For each input FP16 value x, The conversion operation is:k|x.significand|GetMant(x) = Â±2where:Unbiased exponent k depends on the interval range defined by interv and whether the exponent of the source is even or odd.
The sign of the final result is determined by the sign control and the source sign and the leading frac-tion bit.The encoded value of imm8[1:0] and sign control are shown in Table 5-9.Each converted FP16 result is encoded according to the sign control, the unbiased exponent k (adding bias) and a mantissa normalized to the range specified by interv.The GetMant() function follows Table 5-10 when dealing with floating-point special numbers.Table 5-10.
GetMant() Special Float Values BehaviorInputResultExceptions / CommentsNaNQNaN(SRC)Ignore interv.If (SRC = SNaN), then #IE.+1.0Ignore interv.+01.0 Ignore interv.-0IF (SC[0]) THEN +1.0Ignore interv.
                 ELSE -1.0IF (SC[1]) THEN {QNaN_Indefinite} -Ignore interv.ELSE {If (SC[1]), then #IE.
  IF (SC[0]) THEN +1.0                     ELSE -1.01If (SC[1]), then #IE.negativeSC[1] ? QNaN_Indefinite : Getmant(SRC)NOTES:1.
In case SC[1]==0, the sign of Getmant(SRC) is declared according to SC[0].

## Exceptions

- Other Exceptions
- SIMD Floating-Point Exceptions
  > Invalid, Denormal.

## Operation

```C
def getmant_fp16(src, sign_control, normalization_interval):bias := 15dst.sign := sign_control[0] ? 0 : src.signsigned_one := sign_control[0] ? +1.0 : -1.0dst.exp := src.expdst.fraction := src.fractionzero := (dst.exp = 0) and (dst.fraction = 0)denormal := (dst.exp = 0) and (dst.fraction != 0)infinity := (dst.exp = 0x1F) and (dst.fraction = 0)nan := (dst.exp = 0x1F) and (dst.fraction != 0)src_signaling := src.fraction[9]snan := nan and (src_signaling = 0)positive := (src.sign = 0)negative := (src.sign = 1)if nan:if snan:MXCSR.IE := 1return qnan(src)if positive and (zero or infinity):return 1.0if negative:if zero:if sign_control[1]:MXCSR.IE := 1return QNaN_Indefinitereturn signed_oneif sign_control[1]:MXCSR.IE := 1return QNaN_Indefiniteif denormal:jbit := 0dst.exp := bias // set exponent to bias valuewhile jbit = 0:jbit := dst.fraction[9]dst.fraction := dst.fraction << 1dst.exp : = dst.exp - 1MXCSR.DE := 1unbaiased_exp := dst.exp - biasodd_exp := unbaiased_exp[0]signaling_bit := dst.fraction[9]if normalization_interval = 0b00:dst.exp := biaselse if normalization_interval = 0b01:dst.exp := odd_exp ? bias-1 : biaselse if normalization_interval = 0b10:dst.exp := bias-1else if normalization_interval = 0b11:dst.exp := signaling_bit ? bias-1 : biasreturn dstVGETMANTPH dest{k1}, src, imm8 VL = 128, 256 or 512KL := VL/16sign_control := imm8[3:2]normalization_interval := imm8[1:0]FOR i := 0 to KL-1:IF k1[i] or *no writemask*:IF SRC is memory and (EVEX.b = 1):tsrc := src.fp16[0]ELSE:tsrc := src.fp16[i]DEST.fp16[i] := getmant_fp16(tsrc, sign_control, normalization_interval)ELSE IF *zeroing*:DEST.fp16[i] := 0Intel C/C++ Compiler Intrinsic EquivalentVGETMANTPH __m128h _mm_getmant_ph (__m128h a, _MM_MANTISSA_NORM_ENUM norm, _MM_MANTISSA_SIGN_ENUM sign);VGETMANTPH __m128h _mm_mask_getmant_ph (__m128h src, __mmask8 k, __m128h a, _MM_MANTISSA_NORM_ENUM norm, _MM_MANTISSA_SIGN_ENUM sign);VGETMANTPH __m128h _mm_maskz_getmant_ph (__mmask8 k, __m128h a, _MM_MANTISSA_NORM_ENUM norm, _MM_MANTISSA_SIGN_ENUM sign);VGETMANTPH __m256h _mm256_getmant_ph (__m256h a, _MM_MANTISSA_NORM_ENUM norm, _MM_MANTISSA_SIGN_ENUM sign);VGETMANTPH __m256h _mm256_mask_getmant_ph (__m256h src, __mmask16 k, __m256h a, _MM_MANTISSA_NORM_ENUM norm, _MM_MANTISSA_SIGN_ENUM sign);VGETMANTPH __m256h _mm256_maskz_getmant_ph (__mmask16 k, __m256h a, _MM_MANTISSA_NORM_ENUM norm, _MM_MANTISSA_SIGN_ENUM sign);VGETMANTPH __m512h _mm512_getmant_ph (__m512h a, _MM_MANTISSA_NORM_ENUM norm, _MM_MANTISSA_SIGN_ENUM sign);VGETMANTPH __m512h _mm512_mask_getmant_ph (__m512h src, __mmask32 k, __m512h a, _MM_MANTISSA_NORM_ENUM norm, _MM_MANTISSA_SIGN_ENUM sign);VGETMANTPH __m512h _mm512_maskz_getmant_ph (__mmask32 k, __m512h a, _MM_MANTISSA_NORM_ENUM norm, _MM_MANTISSA_SIGN_ENUM sign);VGETMANTPH __m512h _mm512_getmant_round_ph (__m512h a, _MM_MANTISSA_NORM_ENUM norm, _MM_MANTISSA_SIGN_ENUM sign, const int sae);VGETMANTPH __m512h _mm512_mask_getmant_round_ph (__m512h src, __mmask32 k, __m512h a, _MM_MANTISSA_NORM_ENUM norm, _MM_MANTISSA_SIGN_ENUM sign, const int sae);VGETMANTPH __m512h _mm512_maskz_getmant_round_ph (__mmask32 k, __m512h a, _MM_MANTISSA_NORM_ENUM norm, _MM_MANTISSA_SIGN_ENUM sign, const int sae);
```
