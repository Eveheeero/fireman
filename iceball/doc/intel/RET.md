# RET

Return From Procedure

Transfers program control to a return address located on the top of the stack.
The address is usually placed on the stack by a CALL instruction, and the return is made to the instruction that follows the CALL instruction.The optional source operand specifies the number of stack bytes to be released after the return address is popped; the default is none.
This operand can be used to release parameters from the stack that were passed to the called procedure and are no longer needed.
It must be used when the CALL instruction used to switch to a new procedure uses a call gate with a non-zero word count to access the new procedure.
Here, the source operand for the RET instruction must specify the same number of bytes as is specified in the word count field of the call gate.The RET instruction can be used to execute three different types of returns: - Near return - A return to a calling procedure within the current code segment (the segment currently pointed to by the CS register), sometimes referred to as an intrasegment return.
- Far return - A return to a calling procedure located in a different segment than the current code segment, sometimes referred to as an intersegment return.
- Inter-privilege-level far return - A far return to a different privilege level than that of the currently executing program or procedure.The inter-privilege-level return type can only be executed in protected mode.
See the section titled "Calling Proce-®dures Using Call and RET" in Chapter 6 of the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, for detailed information on near, far, and inter-privilege-level returns.When executing a near return, the processor pops the return instruction pointer (offset) from the top of the stack into the EIP register and begins program execution at the new instruction pointer.
The CS register is unchanged.
When executing a far return, the processor pops the return instruction pointer from the top of the stack into the EIP register, then pops the segment selector from the top of the stack into the CS register.
The processor then begins program execution in the new code segment at the new instruction pointer.The mechanics of an inter-privilege-level far return are similar to an intersegment return, except that the processor examines the privilege levels and access rights of the code and stack segments being returned to determine if the control transfer is allowed to be made.
The DS, ES, FS, and GS segment registers are cleared by the RET instruction during an inter-privilege-level return if they refer to segments that are not allowed to be accessed at the new priv-ilege level.
Since a stack switch also occurs on an inter-privilege level return, the ESP and SS registers are loaded from the stack.
If parameters are passed to the called procedure during an inter-privilege level call, the optional source operand must be used with the RET instruction to release the parameters on the return.
Here, the parameters are released both from the called procedure's stack and the calling procedure's stack (that is, the stack being returned to).In 64-bit mode, the default operation size of this instruction is the stack-address size, i.e., 64 bits.
This applies to Refer to Chapter 6, "Procedure Calls, Interrupts, and Exceptions" and Chapter 17, "Control-flow Enforcement ®Technology (CET)" in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, for CET details.Instruction ordering.
Instructions following a far return may be fetched from memory before earlier instructions complete execution, but they will not execute (even speculatively) until all instructions prior to the far return have completed execution (the later instructions may execute before data stored by the earlier instructions have become globally visible).Unlike near indirect CALL and near indirect JMP, the processor will not speculatively execute the next sequential instruction after a near RET unless that instruction is also the target of a jump or is a target in a branch predictor.

## Flags affected

- None.

## Exceptions

- Real-Address Mode Exceptions
  - #GP - If the return instruction pointer is not within the return code segment limit
  - #SS - If the top bytes of stack are not within stack limits.
- 64-Bit Mode Exceptions
  - #GP(0) - If the return instruction pointer is non-canonical.
  > If the return instruction pointer is no
  > t within the return code segment limit.
  > If the stack segment selector is NULL
  >  going back to compatibility mode.
  > If the stack segment selector is NULL going back to CPL3 64-bit mode.
  > If a NULL stack segment selector RPL is not equal to CPL going back to non-CPL3 64-bit mode.
  > If the return code segment selector is NULL.
  > If returning to 32-bit or compatibility mode and the previous SSP from shadow stack (when 
  > returning to CPL <3) or from IA32_PL3_SS
  > P (returning to CPL 3) is beyond 4GB.
  - #GP(selector) - If the proposed segment descriptor for a code
  >  segment does not indicate it is a code segment. 
  > If the proposed new code segment descriptor has both the D-bit and L-bit set.
  > If the DPL for a nonconforming-code segment is
  >  not equal to the RPL of the code segment 
  > selector.
  > If CPL is greater than the RPL 
  > of the code segment selector.
  > If the DPL of a conforming-code segment is gr
  > eater than the return code segment selector 
  > RPL.
  > If a segment selector index is outside its descriptor table limits.
  > If a segment descriptor memory address is non-canonical.
  > If the stack segment is not a writable data segment.
  > If the stack segment descriptor DPL is not equal to the RPL of the return code segment 
  > selector.
  > If the stack segment selector RPL is not equal to
  >  the RPL of the return code segment selector. 
  - #SS(0) - If an attempt to pop a value off the stack violates the SS limit.
  > If an attempt to pop a value off the stack causes a non-canonical address to be referenced.
  - #NP(selector) - If the return code or stack segment is not present.
  - #PF(fault-code) - If a page fault occurs.
  - #AC(0) - If alignment checking is enabled and an
  > unaligned memory reference is made while the 
  > current privilege level is 3.
  > #CP(Far-RET/IRET)If the previous SSP from shadow st
  > ack (when returning to CPL <3) or from IA32_PL3_SSP 
- Protected Mode Exceptions
  - #GP(0) - If the return code or stack segment selector is NULL.
  > If the return instruction pointer is not within the return code segment limit.
  > If returning to 32-bit or compatibility mode and the previous SSP from shadow stack (when 
  > returning to CPL <3) or fr
  > om IA32_PL3_SSP (returning to CPL 3) is beyond 4GB.
  - #GP(selector) - If the RPL of the return code segment selector is less then the CPL.
  > If the return code or stack segment selector 
  > index is not within its descriptor table limits.
  > If the return code segment descripto
  > r does not indicate a code segment.
  > If the return code segment is non-conforming 
  > and the segment selector's DPL is not equal to 
  > the RPL of the code segment's segment selector
  > If the return code segment is conforming and 
  > the segment selector's DPL greater than the RPL 
  > of the code segment's segment selector
  > If the stack segment is not a writable data segment.
  > If the stack segment selector RPL is not equal to
  >  the RPL of the return code segment selector.
  > If the stack segment descriptor DPL is not eq
  > ual to the RPL of the return code segment 
  > selector.
  - #SS(0) - If the top bytes of stack are not within stack limits.
  > If the return stack segment is not present.
  - #NP(selector) - If the return code segment is not present.
  - #PF(fault-code) - If a page fault occurs.
  - #AC(0) - If an unaligned memory access occurs when
  > the CPL is 3 and alignment checking is enabled.
  > #CP(Far-RET/IRET)If the previous SSP from shadow st
  > ack (when returning to CPL <3) or from IA32_PL3_SSP 
  > (returning to CPL 3) is not 4 byte aligned.
  > If return instruction pointer from stack and shadow stack do not match.
- Virtual-8086 Mode Exceptions
  - #GP(0) - If the return instruction pointer is not within the return code segment limit
  - #SS(0) - If the top bytes of stack are not within stack limits.
  - #PF(fault-code) - If a page fault occurs.
  - #AC(0) - If an unaligned memory access occurs
  >  when alignment checking is enabled.

## Operation

```C
(* Near return *) IF instruction =near return THEN;IF OperandSize = 32THENIF top 4 bytes of stack not within stack limitsTHEN #SS(0); FI;EIP := Pop();IF ShadowStackEnabled(CPL)tempSsEIP = ShadowStackPop4B();IF EIP != TempSsEIPTHEN #CP(NEAR_RET); FI;FI;ELSEIF OperandSize = 64THENIF top 8 bytes of stack not within stack limitsTHEN #SS(0); FI;RIP := Pop();IF ShadowStackEnabled(CPL)tempSsEIP = ShadowStackPop8B();IF RIP != tempSsEIPTHEN #CP(NEAR_RET); FI;FI;  =16 *)ELSE (* OperandSizeIF top 2 bytes of stack not within stack limitsTHEN #SS(0); FI;tempEIP := Pop();tempEIP := tempEIP AND 0000FFFFH;IF tempEIP not within code segment limitsTHEN #GP(0); FI;EIP := tempEIP;IF ShadowStackEnabled(CPL)tempSsEip = ShadowStackPop4B();IF EIP != tempSsEIPTHEN #CP(NEAR_RET); FI;FI;FI;FI;IF instruction has immediate operandTHEN (* Release parameters from stack *) = THEN ESP := ESP + SRC;ELSE=IF StackAddressSize  64THEN RSP := RSP + SRC;=ELSE (* StackAddressSize  16 *)SP := SP + SRC;FI;FI;FI;FI;(* Real-address mode or virtual-8086 mode *) IF ((PE = 0) or (PE = 1 AND VM = 1)) and instruction =far returnTHENIF OperandSize = 32THENIF top 8 bytes of stack not within stack limitsTHEN #SS(0); FI;EIP := Pop(); CS := Pop(); (* 32-bit pop, high-order 16 bits discarded *)ELSE (* OperandSize = 16 *)IF top 4 bytes of stack not within stack limitsTHEN #SS(0); FI;tempEIP := Pop(); tempEIP := tempEIP AND 0000FFFFH;IF tempEIP not within code segment limitsTHEN #GP(0); FI;EIP := tempEIP;CS := Pop(); (* 16-bit pop *)FI;IF instruction has immediate operand THEN (* Release parameters from stack *)SP := SP + (SRC AND FFFFH);FI;FI;(* Protected mode, not virtual-8086 mode *)  = 0 and IA32_EFER.LMA = 0) and instruction =far returnIF (PE = 1 and VMTHENIF OperandSize = 32THEN IF second doubleword on stack is not within stack limitsTHEN #SS(0); FI;ELSE (* OperandSize = 16 *)IF second word on stack is not within stack limitsTHEN #SS(0); FI;FI;IF return code segment selector is NULLTHEN #GP(0); FI;IF return code segment selector addresses descriptor beyond descriptor table limit IF return code segment descriptor is not a code segmentTHEN #GP(selector); FI;IF return code segment selector RPL < CPLTHEN #GP(selector); FI;IF return code segment descriptor is conformingand return code segment DPL > return code segment selector RPLTHEN #GP(selector); FI;IF return code segment descriptor is non-conforming and return code  return code segment selector RPLsegment DPL THEN #GP(selector); FI;IF return code segment descriptor is not presentTHEN #NP(selector); FI:IF return code segment selector RPL > CPL THEN GOTO RETURN-TO-OUTER-PRIVILEGE-LEVEL;ELSE GOTO RETURN-TO-SAME-PRIVILEGE-LEVEL;FI;FI; RETURN-TO-SAME-PRIVILEGE-LEVEL:IF the return instruction pointer is not within the return code segment limit THEN #GP(0); FI;= IF OperandSize 32THENEIP := Pop();CS := Pop(); (* 32-bit pop, high-order 16 bits discarded *)= 16 *)ELSE (* OperandSize EIP := Pop();EIP := EIP AND 0000FFFFH;CS := Pop(); (* 16-bit pop *)FI;IF instruction has immediate operandTHEN (* Release parameters from stack *) = 32IF StackAddressSizeTHEN ESP := ESP + SRC;=ELSE (* StackAddressSize  16 *)SP := SP + SRC;FI;FI;IF ShadowStackEnabled(CPL)(* SSP must be 8 byte aligned *)IF SSP AND 0x7 != 0THEN #CP(FAR-RET/IRET); FI;tempSsCS = shadow_stack_load 8 bytes from SSP+16;tempSsLIP = shadow_stack_load 8 bytes from SSP+8;prevSSP = shadow_stack_load 8 bytes from SSP;SSP = SSP + 24;(* do a 64 bit-compare to check if any bits beyond bit 15 are set *)tempCS = CS; (* zero pad to 64 bit *)IF tempCS != tempSsCSTHEN #CP(FAR-RET/IRET); FI;(* do a 64 bit-compare; pad CSBASE+RIP with 0 for 32 bit LIP*)(* prevSSP must be 4 byte aligned *)IF prevSSP AND 0x3 != 0THEN #CP(FAR-RET/IRET); FI;(* In legacy mode SSP must be in low 4GB *)IF prevSSP[63:32] != 0THEN #GP(0); FI;SSP := prevSSPFI;RETURN-TO-OUTER-PRIVILEGE-LEVEL:= 32) IF top (16 + SRC) bytes of stack are not within stack limits (OperandSize = or top (8 + SRC) bytes of stack are not within stack limits (OperandSize 16)THEN #SS(0); FI;Read return segment selector;IF stack segment selector is NULLTHEN #GP(0); FI;IF return stack segment selector index is not within its descriptor table limitsTHEN #GP(selector); FI;Read segment descriptor pointed to by return segment selector; RPL of the return code segment selectorIF stack segment selector RPL or stack segment is not a writable data segment or stack segment descriptor DPL RPL of the return code segment selectorTHEN #GP(selector); FI;IF stack segment not presentTHEN #SS(StackSegmentSelector); FI;IF the return instruction pointer is not within the return code segment limitTHEN #GP(0); FI;=IF OperandSize  32THENEIP := Pop();CS := Pop(); (* 32-bit pop, high-order 16 bits discarded; segment descriptor loaded *)CS(RPL) := ReturnCodeSegmentSelector(RPL);IF instruction has immediate operandTHEN (* Release parameters from called procedure's stack *) = 32IF StackAddressSizeTHEN ESP := ESP + SRC;=ELSE (* StackAddressSize  16 *)SP := SP + SRC;FI;FI;tempESP := Pop();tempSS := Pop(); (* 32-bit pop, high-order 16 bits discarded; seg. descriptor loaded *)= 16 *)ELSE (* OperandSize EIP := Pop();EIP := EIP AND 0000FFFFH;CS := Pop(); (* 16-bit pop; segment descriptor loaded *)CS(RPL) := ReturnCodeSegmentSelector(RPL);IF instruction has immediate operandTHEN (* Release parameters from called procedure's stack *) = 32IF StackAddressSizeTHEN ESP := ESP + SRC;=ELSE (* StackAddressSize SP := SP + SRC;FI;FI;tempESP := Pop();tempSS := Pop(); (* 16-bit pop; segment descriptor loaded *)FI;IF ShadowStackEnabled(CPL)(* check if 8 byte aligned *)IF SSP AND 0x7 != 0THEN #CP(FAR-RET/IRET); FI;IF ReturnCodeSegmentSelector(RPL) !=3THENtempSsCS = shadow_stack_load 8 bytes from SSP+16;tempSsLIP = shadow_stack_load 8 bytes from SSP+8;tempSSP = shadow_stack_load 8 bytes from SSP;SSP = SSP + 24;(* Do 64 bit compare to detect bits beyond 15 being set *)tempCS = CS; (* zero extended to 64 bit *)IF tempCS != tempSsCSTHEN #CP(FAR-RET/IRET); FI;(* Do 64 bit compare; pad CSBASE+RIP with 0 for 32 bit LA *)IF CSBASE + RIP != tempSsLIPTHEN #CP(FAR-RET/IRET); FI;(* check if 4 byte aligned *)IF tempSSP AND 0x3 != 0THEN #CP(FAR-RET/IRET); FI;FI;FI;tempOldCPL = CPL;CPL := ReturnCodeSegmentSelector(RPL);ESP := tempESP;SS := tempSS;tempOldSSP = SSP;IF ShadowStackEnabled(CPL)IF CPL = 3THEN tempSSP := IA32_PL3_SSP; FI;IF tempSSP[63:32] != 0THEN #GP(0); FI;SSP := tempSSPFI;(* Now past all faulting points; safe to free the token. The token free is done using the old SSP * and using a supervisor override as old CPL was a supervisor privilege level *)IF ShadowStackEnabled(tempOldCPL)expected_token_value = tempOldSSP | BUSY_BIT (* busy bit - bit position 0 - must be set *)new_token_value = tempOldSSP                      (* clear the busy bit *)shadow_stack_lock_cmpxchg8b(tempOldSSP, new_token_value, expected_token_value)FI;FI;FOR each SegReg in (ES, FS, GS, and DS)DOTHEN (* Segment register invalid *)SegmentSelector := 0; (*Segment selector becomes null*)FI;OD;IF instruction has immediate operandTHEN (* Release parameters from calling procedure's stack *) =IF StackAddressSize 32THEN ESP := ESP + SRC;=ELSE (* StackAddressSize  16 *)SP := SP + SRC;FI;FI;(* IA-32e Mode *)IF (PE = 1 and VM = 0 and IA32_EFER.LMA = 1) and instruction = far returnTHENIF OperandSize = 32THEN IF second doubleword on stack is not within stack limitsTHEN #SS(0); FI;IF first or second doubleword on stack is not in canonical spaceTHEN #SS(0); FI;ELSE IF OperandSize = 16THENIF second word on stack is not within stack limitsTHEN #SS(0); FI;IF first or second word on stack is not in canonical spaceTHEN #SS(0); FI;  ELSE (* OperandSize=64 *)IF first or second quadword on stack is not in canonical space THEN #SS(0); FI;FIFI;IF return code segment selector is NULLTHEN GP(0); FI;IF return code segment selector addresses descriptor beyond descriptor table limit THEN GP(selector); FI;IF return code segment selector addresses descriptor in non-canonical spaceTHEN GP(selector); FI;Obtain descriptor to which return code segment selector points from descriptor table;IF return code segment descriptor is not a code segment THEN #GP(selector); FI;IF return code segment descriptor has L-bit = 1 and D-bit = 1 THEN #GP(selector); FI;IF return code segment selector RPL < CPL THEN #GP(selector); FI;IF return code segment descriptor is conformingand return code segment DPL > return code segment selector RPLTHEN #GP(selector); FI;IF return code segment descriptor is non-conforming THEN #GP(selector); FI;IF return code segment descriptor is not present THEN #NP(selector); FI:IF return code segment selector RPL > CPL THEN GOTO IA-32E-MODE-RETURN-TO-OUTER-PRIVILEGE-LEVEL;ELSE GOTO IA-32E-MODE-RETURN-TO-SAME-PRIVILEGE-LEVEL;FI; FI;IA-32E-MODE-RETURN-TO-SAME-PRIVILEGE-LEVEL:IF the return instruction pointer is not within the return code segment limit THEN #GP(0); FI;IF the return instruction pointer is not within canonical address spaceTHEN #GP(0); FI; = 32IF OperandSizeTHENEIP := Pop();CS := Pop(); (* 32-bit pop, high-order 16 bits discarded *)ELSE IF OperandSize = 16THENEIP := Pop();EIP := EIP AND 0000FFFFH;CS := Pop(); (* 16-bit pop *)= 64 *)ELSE (* OperandSize RIP := Pop();CS := Pop(); (* 64-bit pop, high-order 48 bits discarded *)FI;FI; IF instruction has immediate operandTHEN (* Release parameters from stack *) = 32IF StackAddressSizeTHEN ESP := ESP + SRC;ELSEIF StackAddressSize = 16THENSP := SP + SRC;=ELSE (* StackAddressSize  64 *)RSP := RSP + SRC;FI;FI;FI;IF ShadowStackEnabled(CPL)IF SSP AND 0x7 != 0 (* check if aligned to 8 bytes *)THEN #CP(FAR-RET/IRET); FI;tempSsCS = shadow_stack_load 8 bytes from SSP+16;tempSsLIP = shadow_stack_load 8 bytes from SSP+8;tempSSP = shadow_stack_load 8 bytes from SSP;SSP = SSP + 24;tempCS = CS; (* zero padded to 64 bit *)IF tempCS != tempSsCS (* 64 bit compare; CS zero padded to 64 bits *)THEN #CP(FAR-RET/IRET); FI;THEN #CP(FAR-RET/IRET); FI;IF tempSSP AND 0x3 != 0 (* check if aligned to 4 bytes *)THEN #CP(FAR-RET/IRET); FI;IF (CS.L = 0 AND tempSSP[63:32] != 0) OR(CS.L = 1 AND tempSSP is not canonical relative to the current paging mode)THEN #GP(0); FI;SSP := tempSSPFI;IA-32E-MODE-RETURN-TO-OUTER-PRIVILEGE-LEVEL:IF top (16 + SRC) bytes of stack are not within stack limits (OperandSize = 32) or top (8 + SRC) bytes of stack are not within stack limits (OperandSize = 16)THEN #SS(0); FI;IF top (16 + SRC) bytes of stack are not in canonical address space (OperandSize =32) or top (8 + SRC) bytes of stack are not in canonical address space (OperandSize = 16)or top (32 + SRC) bytes of stack are not in canonical address space (OperandSize = 64)THEN #SS(0); FI;Read return stack segment selector;IF stack segment selector is NULLTHENIF new CS descriptor L-bit = 0 THEN #GP(selector);IF stack segment selector RPL = 3THEN #GP(selector);FI;IF return stack segment descriptor is not within descriptor table limitsTHEN #GP(selector); FI;IF return stack segment descriptor is in non-canonical address spaceTHEN #GP(selector); FI;Read segment descriptor pointed to by return segment selector; RPL of the return code segment selectorIF stack segment selector RPL or stack segment is not a writable data segment or stack segment descriptor DPL RPL of the return code segment selectorTHEN #GP(selector); FI;IF stack segment not present THEN #SS(StackSegmentSelector); FI;IF the return instruction pointer is not within the return code segment limit THEN #GP(0); FI:IF the return instruction pointer is not within canonical address space THEN #GP(0); FI;=IF OperandSize  32THENEIP := Pop();CS := Pop(); (* 32-bit pop, high-order 16 bits discarded, segment descriptor loaded *)CS(RPL) := ReturnCodeSegmentSelector(RPL);IF instruction has immediate operandTHEN (* Release parameters from called procedure's stack *) = 32IF StackAddressSizeTHEN ESP := ESP + SRC;ELSEIF StackAddressSize = 16THENSP := SP =ELSE (* StackAddressSize  64 *)RSP := RSP + SRC;FI;FI;FI;tempESP := Pop();tempSS := Pop(); (* 32-bit pop, high-order 16 bits discarded, segment descriptor loaded *)ELSE IF OperandSize = 16THENEIP := Pop();EIP := EIP AND 0000FFFFH;CS := Pop(); (* 16-bit pop; segment descriptor loaded *)CS(RPL) := ReturnCodeSegmentSelector(RPL);IF instruction has immediate operandTHEN (* Release parameters from called procedure's stack *) = 32IF StackAddressSizeTHEN ESP := ESP + SRC;ELSEIF StackAddressSize = 16THENSP := SP + SRC;=ELSE (* StackAddressSize  64 *)RSP := RSP + SRC;FI;FI;FI;tempESP := Pop();tempSS := Pop(); (* 16-bit pop; segment descriptor loaded *)= 64 *)ELSE (* OperandSize RIP := Pop();CS := Pop(); (* 64-bit pop; high-order 48 bits discarded; seg. descriptor loaded *)CS(RPL) := ReturnCodeSegmentSelector(RPL);IF instruction has immediate operandTHEN (* Release parameters from called procedure's stack *)RSP := RSP + SRC;FI;tempESP := Pop();tempSS := Pop(); (* 64-bit pop; high-order 48 bits discarded; seg. desc. loaded *)FI;FI;IF ShadowStackEnabled(CPL)(* check if 8 byte aligned *)IF SSP AND 0x7 != 0THEN #CP(FAR-RET/IRET); FI;IF ReturnCodeSegmentSelector(RPL) !=3THENtempSsCS = shadow_stack_load 8 bytes from SSP+16;tempSsLIP = shadow_stack_load 8 bytes from SSP+8;tempSSP = shadow_stack_load 8 bytes from SSP;tempCS = CS; (* zero padded to 64 bit *)IF tempCS != tempSsCSTHEN #CP(FAR-RET/IRET); FI;(* Do 64 bit compare; pad CSBASE+RIP with 0 for 32 bit LIP *)IF CSBASE + RIP != tempSsLIPTHEN #CP(FAR-RET/IRET); FI;(* check if 4 byte aligned *)IF tempSSP AND 0x3 != 0THEN #CP(FAR-RET/IRET); FI;FI;FI;tempOldCPL = CPL;CPL := ReturnCodeSegmentSelector(RPL);ESP := tempESP;SS := tempSS;tempOldSSP = SSP;IF ShadowStackEnabled(CPL)IF CPL = 3THEN tempSSP := IA32_PL3_SSP; FI;IF (CS.L = 0 AND tempSSP[63:32] != 0) OR(CS.L = 1 AND tempSSP is not canonical relative to the current paging mode)THEN #GP(0); FI;SSP := tempSSPFI;(* Now past all faulting points; safe to free the token. The token free is done using the old SSP* and using a supervisor override as old CPL was a supervisor privilege level *)IF ShadowStackEnabled(tempOldCPL)expected_token_value = tempOldSSP | BUSY_BIT  (* busy bit - bit position 0 - must be set *)new_token_value = tempOldSSP                      (* clear the busy bit *)shadow_stack_lock_cmpxchg8b(tempOldSSP, new_token_value, expected_token_value)FI;FOR each of segment register (ES, FS, GS, and DS)DOIF segment register points to data or non-conforming code segmentand CPL > segment descriptor DPL; (* DPL in hidden part of segment register *)THEN SegmentSelector := 0; (* SegmentSelector invalid *)FI;OD;IF instruction has immediate operandTHEN (* Release parameters from calling procedure's stack *) = 32IF StackAddressSizeTHEN ESP := ESP + SRC;ELSEIF StackAddressSize = 16THENSP := SP + SRC;=ELSE (* StackAddressSize  64 *)RSP := RSP + SRC;FI;
```
