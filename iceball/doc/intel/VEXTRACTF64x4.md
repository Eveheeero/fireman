# VEXTRACTF64x4

Extract Packed Floating-Point Values

VEXTRACTF128/VEXTRACTF32x4 and VEXTRACTF64x2 extract 128-bits of single precision floating-point values from the source operand (the second operand) and store to the low 128-bit of the destination operand (the first operand).
The 128-bit data extraction occurs at an 128-bit granular offset specified by imm8[0] (256-bit) or imm8[1:0] as the multiply factor.
The destination may be either a vector register or an 128-bit memory location.VEXTRACTF32x4: The low 128-bit of the destination operand is updated at 32-bit granularity according to the writemask.VEXTRACTF32x8 and VEXTRACTF64x4 extract 256-bits of double precision floating-point values from the source operand (second operand) and store to the low 256-bit of the destination operand (the first operand).
The 256-bit data extraction occurs at an 256-bit granular offset specified by imm8[0] (256-bit) or imm8[0] as the multiply factor The destination may be either a vector register or a 256-bit memory location.VEXTRACTF64x4: The low 256-bit of the destination operand is updated at 64-bit granularity according to the writemask.VEX.vvvv and EVEX.vvvv If VEXTRACTF128 is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will cause an #UD exception.

## Exceptions

- SIMD Floating-Point Exceptions
  > None.
- Other Exceptions
  > VEX-encoded instructions, see Table2-23, "Type 6 Class Exception Conditions."
  > EVEX-encoded instructions, see Table2-54, "Type E6NF Class Exception Conditions."
  > Additionally:
  - #UD - IF VEX.L = 0.
  - #UD - If VEX.vvvv != 1111B or

## Operation

```C
VEXTRACTF32x4 (EVEX Encoded Versions) When Destination is a RegisterVL = 256, 512IF VL = 256CASE (imm8[0]) OF0: TMP_DEST[127:0] := SRC1[127:0]1: TMP_DEST[127:0] := SRC1[255:128]ESAC.FI;IF VL = 512 CASE (imm8[1:0]) OF00: TMP_DEST[127:0] := SRC1[127:0]01: TMP_DEST[127:0] := SRC1[255:128]10: TMP_DEST[127:0] := SRC1[383:256]11: TMP_DEST[127:0] := SRC1[511:384]ESAC.FI;FOR j := 0 TO 3i := j * 32IF k1[j] OR *no writemask*THEN DEST[i+31:i] := TMP_DEST[i+31:i]ELSE IF *merging-masking*; merging-maskingTHEN *DEST[i+31:i] remains unchanged*ELSE *zeroing-masking*; zeroing-maskingDEST[i+31:i] := 0FIFI;ENDFORDEST[MAXVL-1:128] := 0VEXTRACTF32x4 (EVEX Encoded Versions) When Destination is MemoryVL = 256, 512IF VL = 256CASE (imm8[0]) OF0: TMP_DEST[127:0] := SRC1[127:0]1: TMP_DEST[127:0] := SRC1[255:128]ESAC.FI;IF VL = 512 CASE (imm8[1:0]) OF00: TMP_DEST[127:0] := SRC1[127:0]01: TMP_DEST[127:0] := SRC1[255:128]10: TMP_DEST[127:0] := SRC1[383:256]11: TMP_DEST[127:0] := SRC1[511:384]ESAC.FI;FOR j := 0 TO 3i := j * 32THEN DEST[i+31:i] := TMP_DEST[i+31:i]ELSE *DEST[i+31:i] remains unchanged*; merging-maskingFI;ENDFORVEXTRACTF64x2 (EVEX Encoded Versions) When Destination is a RegisterVL = 256, 512IF VL = 256CASE (imm8[0]) OF0: TMP_DEST[127:0] := SRC1[127:0]1: TMP_DEST[127:0] := SRC1[255:128]ESAC.FI;IF VL = 512 CASE (imm8[1:0]) OF00: TMP_DEST[127:0] := SRC1[127:0]01: TMP_DEST[127:0] := SRC1[255:128]10: TMP_DEST[127:0] := SRC1[383:256]11: TMP_DEST[127:0] := SRC1[511:384]ESAC.FI;FOR j := 0 TO 1i := j * 64IF k1[j] OR *no writemask*THEN DEST[i+63:i] := TMP_DEST[i+63:i]ELSE IF *merging-masking*; merging-maskingTHEN *DEST[i+63:i] remains unchanged*ELSE *zeroing-masking*; zeroing-maskingDEST[i+63:i] := 0FIFI;ENDFORDEST[MAXVL-1:128] := 0VEXTRACTF64x2 (EVEX Encoded Versions) When Destination is MemoryVL = 256, 512IF VL = 256CASE (imm8[0]) OF0: TMP_DEST[127:0] := SRC1[127:0]1: TMP_DEST[127:0] := SRC1[255:128]ESAC.FI;IF VL = 512 CASE (imm8[1:0]) OF00: TMP_DEST[127:0] := SRC1[127:0]01: TMP_DEST[127:0] := SRC1[255:128]10: TMP_DEST[127:0] := SRC1[383:256]11: TMP_DEST[127:0] := SRC1[511:384]ESAC.i := j * 64IF k1[j] OR *no writemask*THEN DEST[i+63:i] := TMP_DEST[i+63:i]ELSE *DEST[i+63:i] remains unchanged*; merging-maskingFI;ENDFORVEXTRACTF32x8 (EVEX.U1.512 Encoded Version) When Destination is a RegisterVL = 512CASE (imm8[0]) OF0: TMP_DEST[255:0] := SRC1[255:0]1: TMP_DEST[255:0] := SRC1[511:256]ESAC.FOR j := 0 TO 7i := j * 32IF k1[j] OR *no writemask*THEN DEST[i+31:i] := TMP_DEST[i+31:i]ELSE IF *merging-masking*; merging-maskingTHEN *DEST[i+31:i] remains unchanged*ELSE *zeroing-masking*; zeroing-maskingDEST[i+31:i] := 0FIFI;ENDFORDEST[MAXVL-1:256] := 0VEXTRACTF32x8 (EVEX.U1.512 Encoded Version) When Destination is MemoryCASE (imm8[0]) OF0: TMP_DEST[255:0] := SRC1[255:0]1: TMP_DEST[255:0] := SRC1[511:256]ESAC.FOR j := 0 TO 7i := j * 32IF k1[j] OR *no writemask*THEN DEST[i+31:i] := TMP_DEST[i+31:i]ELSE *DEST[i+31:i] remains unchanged*; merging-maskingFI;ENDFORVEXTRACTF64x4 (EVEX.512 Encoded Version) When Destination is a RegisterVL = 512CASE (imm8[0]) OF0: TMP_DEST[255:0] := SRC1[255:0]1: TMP_DEST[255:0] := SRC1[511:256]ESAC.FOR j := 0 TO 3i := j * 64IF k1[j] OR *no writemask*THEN DEST[i+63:i] := TMP_DEST[i+63:i]IF *merging-masking*; merging-maskingTHEN *DEST[i+63:i] remains unchanged*ELSE *zeroing-masking*; zeroing-maskingDEST[i+63:i] := 0FIFI;ENDFORDEST[MAXVL-1:256] := 0VEXTRACTF64x4 (EVEX.512 Encoded Version) When Destination is MemoryCASE (imm8[0]) OF0: TMP_DEST[255:0] := SRC1[255:0]1: TMP_DEST[255:0] := SRC1[511:256]ESAC.FOR j := 0 TO 3i := j * 64IF k1[j] OR *no writemask*THEN DEST[i+63:i] := TMP_DEST[i+63:i]ELSE ; merging-masking*DEST[i+63:i] remains unchanged*FI;ENDFORVEXTRACTF128 (Memory Destination Form)CASE (imm8[0]) OF0: DEST[127:0] := SRC1[127:0]1: DEST[127:0] := SRC1[255:128]ESAC.VEXTRACTF128 (Register Destination Form)CASE (imm8[0]) OF0: DEST[127:0] := SRC1[127:0]1: DEST[127:0] := SRC1[255:128]ESAC.DEST[MAXVL-1:128] := 0Intel C/C++ Compiler Intrinsic EquivalentVEXTRACTF32x4 __m128 _mm512_extractf32x4_ps(__m512 a, const int nidx);VEXTRACTF32x4 __m128 _mm512_mask_extractf32x4_ps(__m128 s, __mmask8 k, __m512 a, const int nidx);VEXTRACTF32x4 __m128 _mm512_maskz_extractf32x4_ps( __mmask8 k, __m512 a, const int nidx);VEXTRACTF32x4 __m128 _mm256_extractf32x4_ps(__m256 a, const int nidx);VEXTRACTF32x4 __m128 _mm256_mask_extractf32x4_ps(__m128 s, __mmask8 k, __m256 a, const int nidx);VEXTRACTF32x4 __m128 _mm256_maskz_extractf32x4_ps( __mmask8 k, __m256 a, const int nidx);VEXTRACTF32x8 __m256 _mm512_extractf32x8_ps(__m512 a, const int nidx);VEXTRACTF32x8 __m256 _mm512_mask_extractf32x8_ps(__m256 s, __mmask8 k, __m512 a, const int nidx);VEXTRACTF32x8 __m256 _mm512_maskz_extractf32x8_ps( __mmask8 k, __m512 a, const int nidx);VEXTRACTF64x2 __m128d _mm512_extractf64x2_pd(__m512d a, const int nidx);VEXTRACTF64x2 __m128d _mm512_mask_extractf64x2_pd(__m128d s, __mmask8 k, __m512d a, const int nidx);VEXTRACTF64x2 __m128d _mm512_maskz_extractf64x2_pd( __mmask8 k, __m512d a, const int nidx);VEXTRACTF64x2 __m128d _mm256_extractf64x2_pd(__m256d a, const int nidx);VEXTRACTF64x2 __m128d _mm256_mask_extractf64x2_pd(__m128d s, __mmask8 k, __m256d a, const int nidx);VEXTRACTF64x2 __m128d _mm256_maskz_extractf64xVEXTRACTF64x4 __m256d _mm512_mask_extractf64x4_pd(__m256d s, __mmask8 k, __m512d a, const int nidx);VEXTRACTF64x4 __m256d _mm512_maskz_extractf64x4_pd( __mmask8 k, __m512d a, const int nidx);VEXTRACTF128 __m128 _mm256_extractf128_ps (__m256 a, int offset);VEXTRACTF128 __m128d _mm256_extractf128_pd (__m256d a, int offset);VEXTRACTF128 __m128i_mm256_extractf128_si256(__m256i a, int offset);
```
