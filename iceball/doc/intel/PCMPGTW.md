# PCMPGTB/PCMPGTW/PCMPGTD

Compare Packed Signed Integers for Greater Than

Performs an SIMD signed compare for the greater value of the packed byte, word, or doubleword integers in the destination operand (first operand) and the source operand (second operand).
If a data element in the destination operand is greater than the corresponding date element in the source operand, the corresponding data element in the destination operand is set to all 1s; otherwise, it is set to all 0s.The PCMPGTB instruction compares the corresponding signed byte integers in the destination and source oper-ands; the PCMPGTW instruction compares the corresponding signed word integers in the destination and source operands; and the PCMPGTD instruction compares the corresponding signed doubleword integers in the destina-tion and source operands.In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location.
The destination operand can be an MMX technology register.128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location.
The first source operand and destination operand are XMM registers.
Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.
VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location.
The first source operand and destination operand are XMM reVEX.256 encoded version: The first source operand is a YMM register.
The second source operand is a YMM register or a 256-bit memory location.
The destination operand is a YMM register.EVEX encoded VPCMPGTD: The first source operand (second operand) is a ZMM/YMM/XMM register.
The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location.
The destination operand (first operand) is a mask register updated according to the writemask k2.EVEX encoded VPCMPGTB/W: The first source operand (second operand) is a ZMM/YMM/XMM register.
The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location.
The destination operand (first operand) is a mask register updated according to the writemask k2.

## Flags affected

- None.

## Exceptions

- Other Exceptions
  > Non-EVEX-encoded instruction, see Table2-21, "Type 4 Class Exception Conditions."
  > EVEX-encoded VPCMPGTD, see Table2-49, "Type E4 Class Exception Conditions."
- Numeric Exceptions
  > None.

## Operation

```C
PCMPGTB (With 64-bit Operands)IF DEST[7:0] > SRC[7:0]THEN DEST[7:0) := FFH; ELSE DEST[7:0] := 0; FI;(* Continue comparison of 2nd through 7th bytes in DEST and SRC *)IF DEST[63:56] > SRC[63:56]THEN DEST[63:56] := FFH;ELSE DEST[63:56] := 0; FI;COMPARE_BYTES_GREATER (SRC1, SRC2)IF SRC1[7:0] > SRC2[7:0]THEN DEST[7:0] := FFH;ELSE DEST[7:0] := 0; FI;(* Continue comparison of 2nd through 15th bytes in SRC1 and SRC2 *)IF SRC1[127:120] > SRC2[127:120]THEN DEST[127:120] := FFH;ELSE DEST[127:120] := 0; FI;COMPARE_WORDS_GREATER (SRC1, SRC2)IF SRC1[15:0] > SRC2[15:0]THEN DEST[15:0] := FFFFH;ELSE DEST[15:0] := 0; FI;(* Continue comparison of 2nd through 7th 16-bit words in SRC1 and SRC2 *)IF SRC1[127:112] > SRC2[127:112]THEN DEST[127:112] := FFFFH;ELSE DEST[127:112] := 0; FI;COMPARE_DWORDS_GREATER (SRC1, SRC2)IF SRC1[31:0] > SRC2[31:0]THEN DEST[31:0] := FFFFFFFFH;ELSE DEST[31:0] := 0; FI;(* Continue comparison of 2nd through 3rd 32-bit dwords in SRC1 and SRC2 *)IF SRC1[127:96] > SRC2[127:96]THEN DEST[127:96] := FFFFFFFFH;ELSE DEST[127:96] := 0; FI;PCMPGTB (With 128-bit Operands)VPCMPGTB (VEX.128 Encoded Version)DEST[127:0] := COMPARE_BYTES_GREATER(SRC1,SRC2)DEST[MAXVL-1:128] := 0VPCMPGTB (VEX.256 Encoded Version)DEST[127:0] := COMPARE_BYTES_GREATER(SRC1[127:0],SRC2[127:0])DEST[255:128] := COMPARE_BYTES_GREATER(SRC1[255:128],SRC2[255:128])DEST[MAXVL-1:256] := 0VPCMPGTB (EVEX Encoded Versions)(KL, VL) = (16, 128), (32, 256), (64, 512)FOR j := 0 TO KL-1i := j * 8IF k2[j] OR *no writemask*THEN /* signed comparison */CMP := SRC1[i+7:i] > SRC2[i+7:i];IF CMP = TRUETHEN DEST[j] := 1;ELSE DEST[j] := 0; FI;ELSE DEST[j] := 0; zeroing-masking onlyFI;FI;ENDFORDEST[MAX_KL-1:KL] := 0PCMPGTW (With 64-bit Operands)IF DEST[15:0] > SRC[15:0] THEN DEST[15:0] := FFFFH;ELSE DEST[15:0] := 0; FI;(* Continue comparison of 2nd and 3rd words in DEST and SRC *)IF DEST[63:48] > SRC[63:48]THEN DEST[63:48] := FFFFH;ELSE DEST[63:48] := 0; FI;PCMPGTW (With 128-bit Operands)DEST[127:0] := COMPARE_WORDS_GREATER(DEST[127:0],SRC[127:0])DEST[MAXVL-1:128] (Unmodified)VPCMPGTW (VEX.128 Encoded Version)DEST[127:0] := COMPARE_WORDS_GREATER(SRC1,SRC2)DEST[MAXVL-1:128] := 0VPCMPGTW (VEX.256 Encoded Version)DEST[127:0] := COMPARE_WORDS_GREATER(SRC1[127:0],SRC2[127:0])DEST[255:128] := COMPARE_WORDS_GREVPCMPGTW (EVEX Encoded Versions)(KL, VL) = (8, 128), (16, 256), (32, 512)FOR j := 0 TO KL-1i := j * 16IF k2[j] OR *no writemask*THEN /* signed comparison */CMP := SRC1[i+15:i] > SRC2[i+15:i];IF CMP = TRUETHEN DEST[j] := 1;ELSE DEST[j] := 0; FI;ELSE DEST[j] := 0; zeroing-masking onlyFI;FI;ENDFORDEST[MAX_KL-1:KL] := 0PCMPGTD (With 64-bit Operands)IF DEST[31:0] > SRC[31:0]THEN DEST[31:0] := FFFFFFFFH; ELSE DEST[31:0] := 0; FI;IF DEST[63:32] > SRC[63:32]THEN DEST[63:32] := FFFFFFFFH;ELSE DEST[63:32] := 0; FI;PCMPGTD (With 128-bit Operands)DEST[127:0] := COMPARE_DWORDS_GREATER(DEST[127:0],SRC[127:0])DEST[MAXVL-1:128] (Unmodified)VPCMPGTD (VEX.128 Encoded Version)DEST[127:0] := COMPARE_DWORDS_GREATER(SRC1,SRC2)DEST[MAXVL-1:128] := 0VPCMPGTD (VEX.256 Encoded Version)DEST[127:0] := COMPARE_DWORDS_GREATER(SRC1[127:0],SRC2[127:0])DEST[255:128] := COMPARE_DWORDS_GREATER(SRC1[255:128],SRC2[255:128])DEST[MAXVL-1:256] := 0VPCMPGTD (EVEX Encoded Versions)(KL, VL) = (4, 128), (8, 256), (8, 512)FOR j := 0 TO KL-1i := j * 32IF k2[j] OR *no writemask*THEN /* signed comparison */IF (EVEX.b = 1) AND (SRC2 *is memory*)THEN CMP := SRC1[i+31:i] > SRC2[31:0];ELSE CMP := SRC1[i+31:i] > SRC2[i+31:i];FI;IF CMP = TRUETHEN DEST[j] := 1;ELSE DEST[j] := 0; FI;ELSE DEST[j] := 0; zeroing-masking onlyDEST[MAX_KL-1:KL] := 0Intel C/C++ Compiler Intrinsic EquivalentsVPCMPGTB __mmask64 _mm512_cmpgt_epi8_mask(__m512i a, __m512i b);VPCMPGTB __mmask64 _mm512_mask_cmpgt_epi8_mask(__mmask64 k, __m512i a, __m512i b);VPCMPGTB __mmask32 _mm256_cmpgt_epi8_mask(__m256i a, __m256i b);VPCMPGTB __mmask32 _mm256_mask_cmpgt_epi8_mask(__mmask32 k, __m256i a, __m256i b);VPCMPGTB __mmask16 _mm_cmpgt_epi8_mask(__m128i a, __m128i b);VPCMPGTB __mmask16 _mm_mask_cmpgt_epi8_mask(__mmask16 k, __m128i a, __m128i b);VPCMPGTD __mmask16 _mm512_cmpgt_epi32_mask(__m512i a, __m512i b);VPCMPGTD __mmask16 _mm512_mask_cmpgt_epi32_mask(__mmask16 k, __m512i a, __m512i b);VPCMPGTD __mmask8 _mm256_cmpgt_epi32_mask(__m256i a, __m256i b);VPCMPGTD __mmask8 _mm256_mask_cmpgt_epi32_mask(__mmask8 k, __m256i a, __m256i b);VPCMPGTD __mmask8 _mm_cmpgt_epi32_mask(__m128i a, __m128i b);VPCMPGTD __mmask8 _mm_mask_cmpgt_epi32_mask(__mmask8 k, __m128i a, __m128i b);VPCMPGTW __mmask32 _mm512_cmpgt_epi16_mask(__m512i a, __m512i b);VPCMPGTW __mmask32 _mm512_mask_cmpgt_epi16_mask(__mmask32 k, __m512i a, __m512i b);VPCMPGTW __mmask16 _mm256_cmpgt_epi16_mask(__m256i a, __m256i b);VPCMPGTW __mmask16 _mm256_mask_cmpgt_epi16_mask(__mmask16 k, __m256i a, __m256i b);VPCMPGTW __mmask8 _mm_cmpgt_epi16_mask(__m128i a, __m128i b);VPCMPGTW __mmask8 _mm_mask_cmpgt_epi16_mask(__mmask8 k, __m128i a, __m128i b);PCMPGTB __m64 _mm_cmpgt_pi8 (__m64 m1, __m64 m2)PCMPGTW __m64 _mm_cmpgt_pi16 (__m64 m1, __m64 m2)PCMPGTD __m64 _mm_cmpgt_pi32 (__m64 m1, __m64 m2)(V)PCMPGTB __m128i _mm_cmpgt_epi8 ( __m128i a, __m128i b)(V)PCMPGTW __m128i _mm_cmpgt_epi16 ( __m128i a, __m128i b)(V)DCMPGTD __m128i _mm_cmpgt_epi32 ( __m128i a, __m128i b)VPCMPGTB __m256i _mm256_cmpgt_epi8 ( __m256i a, __m256i b)VPCMPGTW __m256i _mm256_cmpgt_epi16 ( __m256i a, __m256i b)VPCMPGTD __m256i _mm256_cmpgt_epi32 ( __m256i a, __m256i b)
```
