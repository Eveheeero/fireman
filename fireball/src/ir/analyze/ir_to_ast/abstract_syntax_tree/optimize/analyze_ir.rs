use std::sync::{Arc, RwLock};

use crate::{
    ir::{
        analyze::{
            DataType,
            ir_to_ast::{
                abstract_syntax_tree::{
                    Ast, AstFunctionId, AstFunctionVersion, AstStatement, AstStatementOrigin,
                    AstValue, AstValueType, AstVariable, AstVariableId, PrintWithConfig, Wrapped,
                },
                convert_stmt, resolve_constant,
            },
        },
        data::IrData,
    },
    prelude::{DecompileError, *},
    utils::Aos,
};
use hashbrown::HashMap;

/// Generate Ast function body with given ir function
pub(super) fn analyze_ir_function(
    ast: &mut Ast,
    function_id: AstFunctionId,
    function_version: AstFunctionVersion,
) -> Result<(), DecompileError> {
    let ir_function;
    let mut body;
    {
        let mut functions = ast.functions.write().unwrap();
        let function = functions
            .get_mut(&function_id)
            .and_then(|x| x.get_mut(&function_version))
            .unwrap();

        // if analyzed, pass
        if function.analyzed {
            return Ok(());
        }

        body = std::mem::take(&mut function.body);
        ir_function = function.ir.clone();
    }

    let mut locals = HashMap::new();
    let mut var_map: HashMap<Aos<IrData>, AstVariableId> = HashMap::new();
    for var in ir_function.get_variables().iter() {
        let var_id = ast.new_variable_id(&function_id);
        let c_type = match var.data_type {
            DataType::Unknown => AstValueType::Unknown,
            DataType::Bool => AstValueType::Bool,
            DataType::Int => AstValueType::Int,
            DataType::Float => AstValueType::Double,
            DataType::StringPointer => AstValueType::Pointer(Box::new(AstValueType::Char)),
            DataType::Char => AstValueType::Char,
            DataType::Address => AstValueType::Pointer(Box::new(AstValueType::Void)),
        };
        let mut const_value: Option<Wrapped<AstValue>> = None;
        for (position, accesses) in var.get_data_accesses().iter() {
            let instruction_arg_size = ir_function.get_instructions()[position.ir_index() as usize]
                .inner
                .arguments
                .len() as u8;
            let position = &ir_function.get_ir()[position.ir_index() as usize].address;
            for da in accesses.iter() {
                var_map.insert(da.location().clone(), var_id);
                // Resolve constant value
                if let Some(c) = resolve_constant(
                    position,
                    instruction_arg_size,
                    &da.location(),
                    &da.location(),
                )? {
                    trace!(
                        "Constant value found in {}: {}",
                        position,
                        c.to_string_with_config(None)
                    );
                    if const_value.is_some() && const_value.as_ref().unwrap() != &c {
                        warn!(
                            "Constant value mismatch in position {}: {} != {}",
                            position,
                            const_value.unwrap().to_string_with_config(None),
                            c.to_string_with_config(None)
                        );
                    }
                    const_value = Some(c);
                }
            }
        }
        locals.insert(
            var_id,
            AstVariable {
                name: var_id.get_default_name(),
                id: var_id,
                var_type: c_type,
                const_value,
            },
        );
    }
    ast.functions
        .write()
        .unwrap()
        .get_mut(&function_id)
        .and_then(|x| x.get_mut(&function_version))
        .unwrap()
        .variables = Arc::new(RwLock::new(locals));

    let map = ir_function.get_instructions().as_ref();
    for ws in &mut body {
        // skip if unanalyzable
        let AstStatement::Ir(stmt) = &ws.statement else {
            continue;
        };
        // skip if ir not generated by instruction
        let AstStatementOrigin::Ir(stmt_position) = &ws.origin else {
            continue;
        };

        let instruction = &map[usize::try_from(stmt_position.descriptor.ir_index())
            .expect("does your architecture smaller than 32bit?")];
        let instruction_args = &instruction.inner.arguments;
        /* analyze and turn into ast */
        let stmt = convert_stmt(
            ast,
            function_id,
            function_version,
            stmt,
            stmt_position,
            None,
            &var_map,
            instruction_args,
        )?;
        *ws = stmt;
    }
    {
        let mut functions = ast.functions.write().unwrap();
        let function = functions
            .get_mut(&function_id)
            .and_then(|x| x.get_mut(&function_version))
            .unwrap();
        function.body = body;
        function.analyzed = true;
    }

    Ok(())
}
