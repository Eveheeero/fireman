//! Module defining `Block`s generated per section by program analysis.

use super::{Address, Relation, Section};
use crate::{core::Instruction, ir::low_ir::IrBlock};
use std::sync::{Arc, RwLock, RwLockReadGuard};

/// IR-level block created by analysis.
///
/// When a `jmp XXXX` instruction is executed, a block starting at `XXXX` is created.
#[derive(Debug)]
pub struct Block {
    /// The block's ID
    id: usize,
    /// The block's name
    name: Option<String>,
    /// The block's start address
    start_address: Address,
    /// The block's size
    block_size: Option<u64>,
    /// Blocks that connect to this block (incoming)
    connected_from: RwLock<Vec<Relation>>,
    /// Blocks this block connects to (outgoing)
    connected_to: RwLock<Vec<Relation>>,
    /// The block's section
    section: Option<Arc<Section>>,
    /// Instructions of the block
    instructions: Arc<[Instruction]>,

    /* Generated by analysis */
    /// The block's IR data
    ir: RwLock<Option<IrBlock>>,
}

impl Block {
    /// Creates a block.
    /// This struct cannot be created directly; it is created and managed by the `blocks` struct.
    ///
    /// ### Arguments
    /// - `id: usize` - block ID
    /// - `name: Option<String>` - block name
    /// - `start_address: Address` - block start address
    /// - `block_size: Option<u64>` - block size
    /// - `instructions: Arc<[Instruction]>` - instructions of the block
    ///
    /// ### Returns
    /// - `Arc<Self>` - the created block
    pub(super) fn new(
        id: usize,
        name: Option<String>,
        start_address: Address,
        block_size: Option<u64>,
        instructions: Arc<[Instruction]>,
    ) -> Arc<Self> {
        let section = start_address.get_section();
        Arc::new(Self {
            id,
            name,
            start_address,
            block_size,
            connected_from: Default::default(),
            connected_to: Default::default(),
            section,
            instructions,
            ir: Default::default(),
        })
    }

    /// Returns the block's ID.
    ///
    /// ### Returns
    /// - `usize` - block ID
    pub fn get_id(&self) -> usize {
        self.id
    }

    /// Returns the block's name.
    ///
    /// ### Returns
    /// - `Option<&String>` - block name
    pub fn get_name(&self) -> Option<&String> {
        self.name.as_ref()
    }

    /// Returns the block's start address.
    ///
    /// ### Returns
    /// - `&Address` - block's start address
    pub fn get_start_address(&self) -> &Address {
        &self.start_address
    }

    /// Returns the block's size.
    ///
    /// ### Returns
    /// - `Option<&u64>` - block size
    pub fn get_block_size(&self) -> Option<&u64> {
        self.block_size.as_ref()
    }

    /// Returns relations for blocks that connect to this block.
    ///
    /// ### Returns
    /// - `RwLockReadGuard<Vec<Relation>>` - connected blocks
    pub fn get_connected_from(&self) -> RwLockReadGuard<Vec<Relation>> {
        self.connected_from.read().unwrap()
    }

    /// Returns relations for blocks this block connects to.
    ///
    /// ### Returns
    /// - `RwLockReadGuard<Vec<Relation>>` - connected blocks
    pub fn get_connected_to(&self) -> RwLockReadGuard<Vec<Relation>> {
        self.connected_to.read().unwrap()
    }

    /// Returns the section of the block.
    ///
    /// ### Returns
    /// - `Option<&Arc<Section>>` - section of the block
    pub fn get_section(&self) -> Option<&Arc<Section>> {
        self.section.as_ref()
    }

    /// Adds a relation for a block connecting to this block.
    ///
    /// ### Arguments
    /// - `relation: Relation` - the block that points to this block
    pub(crate) fn add_connected_from(&self, relation: Relation) {
        self.connected_from.write().unwrap().push(relation);
    }

    /// Adds a relation for a block this block connects to.
    ///
    /// ### Arguments
    /// - `relation: Relation` - the block this block points to
    pub(crate) fn add_connected_to(&self, relation: Relation) {
        self.connected_to.write().unwrap().push(relation);
        debug_assert!(
            self.connected_to.read().unwrap().len() <= 2,
            "One block should not have more than 2 outgoing relations"
        );
    }
    /// Returns whether the block contains a specific address.
    ///
    /// ### Arguments
    /// - `address: &Address` - the address to check
    ///
    /// ### Returns
    /// - `bool` - true if contained, false otherwise
    pub fn contains(&self, address: &Address) -> bool {
        let start_address = self.get_start_address();
        if let Some(block_size) = self.get_block_size() {
            start_address <= address && address - start_address < *block_size
        } else {
            start_address <= address
                && address.get_section().is_some()
                && self.get_section() == address.get_section().as_ref()
        }
    }
    /// Returns the block's IR data.
    ///
    /// ### Returns
    /// - `RwLockReadGuard<Option<IrBlock>>` - IR data of the block
    pub fn get_ir(&self) -> RwLockReadGuard<Option<IrBlock>> {
        self.ir.read().unwrap()
    }
    /// Sets the block's IR data.
    ///
    /// ### Arguments
    /// - `ir: IrBlock` - IR data of the block
    pub fn set_ir(&self, ir: IrBlock) {
        *self.ir.write().unwrap() = Some(ir);
    }
    /// Returns the instructions of the block.
    ///
    /// ### Returns
    /// - `&Arc<[Instruction]>` - instructions of the block
    pub fn get_instructions(&self) -> &Arc<[Instruction]> {
        &self.instructions
    }
}

impl std::hash::Hash for Block {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.id.hash(state);
    }
}

impl Eq for Block {}
impl PartialEq for Block {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}
impl std::fmt::Display for Block {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "({} ~ ", self.start_address)?;
        if let Some(len) = self.block_size {
            write!(f, "{}", &self.start_address + len)?;
        }
        if self.ir.read().unwrap().is_some() {
            write!(f, ")(Analyzed)")
        } else {
            write!(f, ")")
        }
    }
}
